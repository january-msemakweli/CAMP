import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { Implementation, ClientCapabilities, JSONRPCMessage } from '@modelcontextprotocol/sdk/types.js';
import { z } from 'zod';
import { Transport } from '@modelcontextprotocol/sdk/shared/transport.js';

/**
 * A web stream that can be both read from and written to.
 */
interface DuplexStream<T> {
    readable: ReadableStream<T>;
    writable: WritableStream<T>;
}
/**
 * Expands a type into its properties recursively.
 *
 * Useful for providing better intellisense in IDEs.
 */
type ExpandRecursively<T> = T extends (...args: infer A) => infer R ? (...args: ExpandRecursively<A>) => ExpandRecursively<R> : T extends object ? T extends infer O ? {
    [K in keyof O]: ExpandRecursively<O[K]>;
} : never : T;
/**
 * Extracts parameter names from a string path.
 *
 * @example
 * type Path = '/schemas/{schema}/tables/{table}';
 * type Params = ExtractParams<Path>; // 'schema' | 'table'
 */
type ExtractParams<Path extends string> = Path extends `${string}{${infer P}}${infer Rest}` ? P | ExtractParams<Rest> : never;
/**
 * Extracts the request type from an MCP server.
 */
type ExtractRequest<S> = S extends Server<infer R, any, any> ? R : never;
/**
 * Extracts the notification type from an MCP server.
 */
type ExtractNotification<S> = S extends Server<any, infer N, any> ? N : never;
/**
 * Extracts the result type from an MCP server.
 */
type ExtractResult<S> = S extends Server<any, any, infer R> ? R : never;

type Scheme = string;
type Resource<Uri extends string = string, Result = unknown> = {
    uri: Uri;
    name: string;
    description?: string;
    mimeType?: string;
    read(uri: `${Scheme}://${Uri}`): Promise<Result>;
};
type ResourceTemplate<Uri extends string = string, Result = unknown> = {
    uriTemplate: Uri;
    name: string;
    description?: string;
    mimeType?: string;
    read(uri: `${Scheme}://${Uri}`, params: {
        [Param in ExtractParams<Uri>]: string;
    }): Promise<Result>;
};
type Tool<Params extends z.ZodTypeAny = z.ZodTypeAny, Result = unknown> = {
    description: string;
    parameters: Params;
    execute(params: z.infer<Params>): Promise<Result>;
};
/**
 * Helper function to define an MCP resource while preserving type information.
 */
declare function resource<Uri extends string, Result>(uri: Uri, resource: Omit<Resource<Uri, Result>, 'uri'>): Resource<Uri, Result>;
/**
 * Helper function to define an MCP resource with a URI template while preserving type information.
 */
declare function resourceTemplate<Uri extends string, Result>(uriTemplate: Uri, resource: Omit<ResourceTemplate<Uri, Result>, 'uriTemplate'>): ResourceTemplate<Uri, Result>;
/**
 * Helper function to define a JSON resource while preserving type information.
 */
declare function jsonResource<Uri extends string, Result>(uri: Uri, resource: Omit<Resource<Uri, Result>, 'uri' | 'mimeType'>): Resource<Uri, Result>;
/**
 * Helper function to define a JSON resource with a URI template while preserving type information.
 */
declare function jsonResourceTemplate<Uri extends string, Result>(uriTemplate: Uri, resource: Omit<ResourceTemplate<Uri, Result>, 'uriTemplate' | 'mimeType'>): ResourceTemplate<Uri, Result>;
/**
 * Helper function to define a list of resources that share a common URI scheme.
 */
declare function resources<Scheme extends string>(scheme: Scheme, resources: (Resource | ResourceTemplate)[]): (Resource<`${Scheme}://${string}`> | ResourceTemplate<`${Scheme}://${string}`>)[];
/**
 * Helper function to create a JSON resource response.
 */
declare function jsonResourceResponse<Uri extends string, Response>(uri: Uri, response: Response): {
    uri: Uri;
    mimeType: string;
    text: string;
};
/**
 * Helper function to define an MCP tool while preserving type information.
 */
declare function tool<Params extends z.ZodTypeAny, Result>(tool: Tool<Params, Result>): Tool<Params, Result>;
type McpServerOptions = {
    name: string;
    version: string;
    resources?: (Resource<string, unknown> | ResourceTemplate<string, unknown>)[];
    tools?: Record<string, Tool>;
    onInitialize?: (clientInfo: Implementation, clientCapabilities: ClientCapabilities) => void;
};
/**
 * Creates an MCP server with the given options.
 *
 * Simplifies the process of creating an MCP server by providing a high-level
 * API for defining resources and tools.
 */
declare function createMcpServer(options: McpServerOptions): Server<{
    method: string;
    params?: {
        [x: string]: unknown;
        _meta?: {
            [x: string]: unknown;
            progressToken?: string | number | undefined;
        } | undefined;
    } | undefined;
}, {
    method: string;
    params?: {
        [x: string]: unknown;
        _meta?: {
            [x: string]: unknown;
        } | undefined;
    } | undefined;
}, {
    [x: string]: unknown;
    _meta?: {
        [x: string]: unknown;
    } | undefined;
}>;

/**
 * An MCP transport built on top of a duplex stream.
 * It uses a `ReadableStream` to receive messages and a `WritableStream` to send messages.
 *
 * Useful if you wish to pipe messages over your own stream-based transport or directly between two streams.
 */
declare class StreamTransport implements Transport, DuplexStream<JSONRPCMessage> {
    #private;
    ready: Promise<void>;
    readable: ReadableStream<JSONRPCMessage>;
    writable: WritableStream<JSONRPCMessage>;
    onclose?: () => void;
    onerror?: (error: Error) => void;
    onmessage?: (message: JSONRPCMessage) => void;
    constructor();
    start(): Promise<void>;
    send(message: JSONRPCMessage): Promise<void>;
    close(): Promise<void>;
}

export { type DuplexStream, type ExpandRecursively, type ExtractNotification, type ExtractParams, type ExtractRequest, type ExtractResult, type McpServerOptions, type Resource, type ResourceTemplate, type Scheme, StreamTransport, type Tool, createMcpServer, jsonResource, jsonResourceResponse, jsonResourceTemplate, resource, resourceTemplate, resources, tool };
